#!/usr/bin/env python

# The platform-specific variables should be automatically generated by the system
import platform_specific

# instrument
#
# This script is invoked by a user who wishes to enable umdinst
# instrumentation in their account.
import commands
import errno
import os
import re
import sys
import time
from os.path import join,expanduser


# Fix for older versions of Python
try:
    True
except NameError:
    True,False = 1,0



def getlogin():
    """Return the name of the login
    
    We try several things until something works"""
    try:
        return os.environ['USER']
    except:
        try:
            return os.environ['LOGNAME']
        except:
            try:
                import pwd
                return pwd.getpwuid(os.getuid())[0]
            except:
                return os.getlogin()
            


class Instrumenter:
    """Class used for setting up instrumentation

    dirnames - names of directories to be added to path
    hackystat_key - Hackystat key (may be None)
    keyfile - file that contains logins and Hackystat keys
    registerdir - path where we should record that the user has run this script
    javapath - location of Java program
    libdir - folder that contains set up files such as hackyInstaller.jar
    hackystat_host - location of Hackystat server
    logfiledir - directory that contains the logfiles
    repository - directory that will contain the locally created CVS repository
    sandbox - sandbox directory used by local CVS repository
    """
    def __init__(self,
		 dirnames,
		 hackystat_key,
		 keyfile,
		 registerdir,
		 javapath,
		 libdir,
                 with_hackystat,
		 hackystat_host,
		 logfiledir,
		 privatelogfiledir,
                 with_pooledlog,
                 with_privatelog,
                 with_privatecvs,
		 repository,
		 sandbox,
                 additional_path):
        self.dirnames = dirnames
	self.hackystat_key = hackystat_key
        self.keyfile = keyfile
        self.registerdir = registerdir
        self.javapath = javapath
        self.libdir = libdir
        self.with_hackystat = with_hackystat
        self.hackystat_host = hackystat_host
        self.logfiledir = logfiledir
        self.privatelogfiledir = privatelogfiledir
        self.with_pooledlog = with_pooledlog
        self.with_privatelog = with_privatelog
        self.with_privatecvs = with_privatecvs
	self.repository = repository
	self.sandbox = sandbox
        self.additional_path = additional_path

	# Name of the CVS repository 
	self.repository_name = 'umdinst-rep' 

    def java_is_installed(self):
        return (self.javapath is not None) and (self.javapath is not '')

    def add_line_if_not_present(self,line,fname):
        """Add a line to a file, assuming the line is not yet present

        Returns true if the line was already present."""
        # First, check if the line has a newline on it. If it doesn't, terminate it.
        if line[-1]!='\n':
            line = line + '\n'
        if not os.path.isfile(fname):
            open(fname,'w').close()
        f = open(fname,'r')
        lines = f.readlines()
        if line not in lines:
            present = False
            f.close()
            f = open(fname,'a')
            f.write(line)
        else:
            present = True
        f.close()
        return present


    def set_history(self):
	"""Set the history variable to a high value"""
        if (self.login_shell() == 'tcsh'):
            cshrc_file = join(expanduser('~'),'.cshrc')
            self.add_line_if_not_present('set history = 1000',cshrc_file)
        elif (self.login_shell() == 'bash'):
            profile_file = join(expanduser('~'),'.bash_profile')
            self.add_line_if_not_present(' #umdinst',profile_file)
            self.add_line_if_not_present('HISTSIZE=1000',profile_file)
            self.add_line_if_not_present('HISTFILESIZE=1000',profile_file)
            self.add_line_if_not_present('HISTTIMEFORMAT="%s "',profile_file)
            self.add_line_if_not_present('umdinst_bash_history(){(history 1 | sed "s/^/$(date +%s)/")>>~/.bash_history2; }',profile_file)
            self.add_line_if_not_present('export PROMPT_COMMAND=umdinst_bash_history',profile_file)

    def update_path(self):
        """Update the PATH variable in a .cshrc file with a given list"""
        if (self.additional_path is None):
            path_ex = []
        else:
            path_ex = self.additional_path.split(':')
        if (self.login_shell() == 'tcsh'):
            cshrc_file = join(expanduser('~'),'.cshrc')
            pathline = 'setenv PATH %s' % ':'.join(self.dirnames+[os.path.dirname(self.javapath)]+path_ex+['${PATH}'])
            # Check if the line exists. We only modify the file if it doesn't
            already_present = self.add_line_if_not_present(pathline,cshrc_file)
            if already_present:
                print "Your .cshrc already has the PATH set correctly"
            else:
                print "Updating the PATH in your .cshrc file"
        elif (self.login_shell() == 'bash'):
            profile_file = join(expanduser('~'),'.bash_profile')
            bashrc_file = join(expanduser('~'),'.bashrc')
            pathline = 'export PATH=%s' % ':'.join(self.dirnames+[os.path.dirname(self.javapath)]+path_ex+['${PATH}'])
            # Check if the line exists. We only modify the file if it doesn't
            already_present = self.add_line_if_not_present(pathline,profile_file)
            if already_present:
                print "Your .bash_profile already has the PATH set correctly"
            else:
                print "Updating the PATH in your .bash_profile file"
            already_present = self.add_line_if_not_present(pathline,bashrc_file)
            if already_present:
                print "Your .bashrc already has the PATH set correctly"
            else:
                print "Updating the PATH in your .bashrc file"

    def get_hackystat_key(self,login):
        """Get the Hackystat key for this login.

        Currently, does a lookup in a key file, although other solutions are possible.
	Raises a KeyError if the key isn't there"""
        keys = {}

        # We currently read in the whole keyfile, which isn't really necessary
	for line in open(self.keyfile).readlines():
	    user,key = line.split()
	    keys[user] = key
	key = keys[login]
	return key


    def configure_hackystat(self,libdir,hackystat_host,key):
        """Configure Hackystat"""
        # See: http://care.cs.umd.edu:8080/hackystat/docbook/ch02s10.html
        javaprog = self.javapath # os.path.join(self.javapath,'java')
	# Step 1 - Set up the .hackystat directory and verify host and key.
        child_stdin = os.popen('%s -jar %s/hackyInstaller.jar -SetHostAndKey %s %s' % (javaprog,
                                                                          libdir,
                                                                          hackystat_host,
                                                                          key),
                               'r')
        for line in child_stdin.readlines():
            print line
            if (re.match('Failure', line) is not None):
                sys.exit(1)
        # Step 2 - Set paths.  In this case, only the Emacs sensor requires a path specification.
	os.system('%s -jar %s/hackyInstaller.jar -SetPath .EMACS_FILE_DIR $HOME' % (javaprog,
                                                                                libdir))
                                                                                
        # Step 3 - Set properties.  Only the Vim data file needs to be set for this script.
        os.system("%s -jar %s/hackyInstaller.jar -SetProperty HACKYSTAT_VIM_SENSOR_DATA_FILE $HOME/.hackystat/vim/HS_VIM_DATA.dat" % (javaprog,libdir))
        
        # Step 4 - Install/Update sensors.  We do this for Vim, Emacs, and CLI
        os.system("%s -jar %s/hackyInstaller.jar -InstallOrUpdateSensor Emacs" % (javaprog,libdir))
	os.system("%s -jar %s/hackyInstaller.jar -SetProperty ENABLE_EMACS_SENSOR true" % (javaprog,libdir))
	
	
        os.system("%s -jar %s/hackyInstaller.jar -InstallOrUpdateSensor Vim" % (javaprog,libdir))
	os.system("%s -jar %s/hackyInstaller.jar -SetProperty ENABLE_VIM_SENSOR true" % (javaprog,libdir))

        if (self.login_shell() == 'bash'):
            # Haskystat supports only bash 3.0 and later - we can't depend on that yet
            # FIXME: recognize the bash version number somehow
            self.create_no_hackystat_logout_file()
        else:
            os.system("%s -jar %s/hackyInstaller.jar -InstallOrUpdateSensor Cli" % (javaprog,libdir))
            os.system("%s -jar %s/hackyInstaller.jar -SetProperty ENABLE_CLI_SENSOR true" % (javaprog,libdir))

    def record_instrumentation_complete(self):
        """Record that the user has instrumented their account"""
        if self.registerdir is not None:
            user = getlogin()
            f = open(join(expanduser(self.registerdir),user),'w')
            f.write(time.asctime())
            if (self.hackystat_key is not None):
                f.write(' ' + self.hackystat_key)
            f.write('\n')
            f.close()

    def login_shell(self):
        return os.path.basename(os.environ['SHELL'])

    def is_shell_tcsh(self):
        shell = os.path.basename(os.environ['SHELL'])
        return shell == 'tcsh'

    def create_no_hackystat_logout_file(self):
        """Create a .logout file. Used when Hackystat is not available"""
        if self.with_pooledlog:
            histfile = join(self.logfiledir,getlogin()+'.hist')
            tmpfile = join(self.logfiledir,getlogin()+'.tmp')
        elif self.with_privatelog:
            histfile = join(self.privatelogfiledir,getlogin()+'.hist')
            tmpfile = join(self.privatelogfiledir,getlogin()+'.tmp')
        else:
            histfile = '/dev/null'
            from tempfile import gettempdir
            tmpfile = join(gettempdir(),getlogin()+'.tmp')

        if (self.login_shell() == 'tcsh'):
           logout_file = join(expanduser('~'),'.logout')
           logout_text = '''###umdinst - begin
#echo "Collecting command-line data"
history -S %s
cat %s >>! %s
rm -f %s
chmod -f a+r %s
#history -c
###umdinst - end
''' % (tmpfile,tmpfile,histfile,tmpfile,histfile)
        elif (self.login_shell() == 'bash'):
           logout_file = join(expanduser('~'),'.bash_logout')
           logout_text = '''###umdinst - begin
#echo "Collecting command-line data"
history > %s
cat %s >> %s
rm -f %s
chmod -f a+r %s
echo $(date +%s) XXX _logout_ >> ~/.bash_history2
cat ~/.bash_history2 >> %s.2
rm -f ~/.bash_history2
#history -c
###umdinst - end
''' % (tmpfile,tmpfile,histfile,tmpfile,histfile, '%s', histfile)

        # Check if file contains umdinst
        already_installed = False
        try:
            for line in open(logout_file,'r').readlines():
                index = line.find("umdinst")
                if index>=0:
                    already_installed = True
                    break
        except:
            # Nothing to do, it means the file doesn't exist
            pass
        
        if not already_installed:
            f = open(logout_file, 'a')
            f.write(logout_text)

    def create_hackystat_logout_file(self):
        """This function never has to be called since the Hackystat CLI
sensor creates ~/.logout or ~/.bash_logout by itself."""
        logout_file = join(expanduser('~'),'.logout')
        logout_text = """# Begin Hackystat CLI sensor installer code.(provided by HackyInstaller)
echo 'Collecting and sending CLI Sensor data...'
history -S history.hacky.cli
uname -n > uname.hacky.cli
cat uname.hacky.cli history.hacky.cli > data.hacky.cli
% -cp ~/.hackystat/cli/sensorshell.jar:~/.hackystat/cli/sensor.cli.jar org.hackystat.sensor.cli.CliSensor data.hacky.cli
rm -f *.hacky.cli
history -c
echo 'Sending CLI Sensor data...done.'
# End Hackystat CLI sensor installer code.
""" % (self.javapath)
        # Check if file contains Hackystat
        already_installed = False
        try:
            for line in open(logout_file,'r').readlines():
                index = line.find("Hackystat")
                if index>=0:
                    already_installed = True
                    break
        except:
            # Nothing to do, it means the file doesn't exist
            pass
        
        if not already_installed:
            f = open(logout_file, 'a')
            f.write(logout_text)


    def init_cvs(self):
	"""Initialize the CVS-related stuff.

	This creates the repository and sandbox"""
	# Create the CVS repository
        self.create_directory(self.repository)
	(status,output) = commands.getstatusoutput('cvs -d %s init' % self.repository)
	if status!=0:
	    raise ValueError, "Could not create a cvs repository.\nOutput of cvs init command:\n " + output

	# Create the sandbox.
	# The way CVS works requires that we create an empty directory, import it, and then check it out
	os.mkdir('empty-dir')
	os.system('cd empty-dir ; cvs -d %s import -m " " %s umdinst start' % (self.repository,self.repository_name))
	os.rmdir('empty-dir')
	os.system('cvs -d %s co -d %s %s' % (self.repository,self.sandbox,self.repository_name))

#        # Sanity check. Check if the expanded home directory
#        # is the same as the absolute home directory
#        cwd = os.getcwd()
#        home_dir = os.path.expanduser('~')
#        os.chdir(home_dir)
#        fs_dir = os.path.abspath('.')
#        if home_dir!= fs_dir:
#            print """Warning: Your home directory as specified in $HOME (%s) is different from the standard naming convention on this filesystem (%s). 
#You will need to modify your HOME environment variable to be %s or the CVS logging will not work correctly.""" % (home_dir,fs_dir,fs_dir)
#	os.chdir(cwd)


    def create_directory(self, dirname):
        """Create a directory """
        try:
            os.stat(dirname) # Will raise OSError if the file doesn't exist
            if not os.path.isdir(dirname):
                raise ValueError, "%s was specified as a directory, but it is not a directory" % mode
        except OSError:
            print "Directory %s does not exist, creating" % dirname
            os.makedirs(dirname)

    def init_privatelog(self):
        self.create_directory(self.privatelogfiledir)

    def instrument(self):
        if self.with_hackystat and self.java_is_installed():
            self.instrument_with_hackystat()
        else:
            self.instrument_without_hackystat()
        # perform the common setup
	self.set_history()
        self.update_path()
        if self.with_privatecvs:
            self.init_cvs()
        if self.with_privatelog:
            self.init_privatelog()
        self.record_instrumentation_complete()
        print "Your environment has been set up."
        if (self.login_shell() == 'tcsh' or self.login_shell() == 'bash'):
            print "Please log out and log back in for modifications to take effect."
            print "(You may see an error message in your initial logout, this is normal)"
        else:
            print "Warning: Your shell needs to be tcsh or bash for the instrumentation to work."
            print "Please change your default shell to tcsh (e.g. use 'chsh' program)"

    def instrument_without_hackystat(self):
        """Instrument an account, without Hackystat sensors """        
        print "Configuring your account for data collection"
        self.create_no_hackystat_logout_file()

    def instrument_with_hackystat(self):
        """Instrument an account, with Hackystat sensors """
        print "Configuring your account for data collection"

	# Start with the Hackystat key in case it's missing
	if self.hackystat_key is None:
	    try:
		login = getlogin()
		self.hackystat_key = self.get_hackystat_key(login)
	    except KeyError:
		print "Error: no Hackystat key specified"
		print "Usage: instrument hackystat-key"
		print "If you do not yet have a Hackystat key, please obtain one at:"
                print self.hackystat_host + "hackystat"
		sys.exit(1)
		    
	self.configure_hackystat(self.libdir,self.hackystat_host,self.hackystat_key)


if __name__=='__main__':
    if len(sys.argv)==2:
	hackystat_key = sys.argv[1]
    else:
	hackystat_key = None
    i = Instrumenter(dirnames=platform_specific.dirnames,
		     hackystat_key=hackystat_key,
                     keyfile=platform_specific.keyfile,
                     registerdir=platform_specific.registerdir,
                     javapath=platform_specific.javapath,
                     libdir=platform_specific.libdir,
                     with_hackystat=platform_specific.with_hackystat,
                     hackystat_host=platform_specific.hackystat_host,
                     logfiledir=platform_specific.logfiledir,
                     with_pooledlog=platform_specific.with_pooledlog,
                     with_privatelog=platform_specific.with_privatelog,
                     with_privatecvs=platform_specific.with_privatecvs,
                     privatelogfiledir=os.path.expanduser(platform_specific.privatelogfiledir),
		     repository=os.path.expanduser(platform_specific.repository),
		     sandbox=os.path.expanduser(platform_specific.sandbox),
                     additional_path=platform_specific.additional_path)
    i.instrument()
